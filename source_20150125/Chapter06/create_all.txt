SQL> 
SQL> @ddl_.pks
SQL> create or replace package	    DDL_ as
  2  /*
  3  ddl.pks
  4  by Donald J. Bales on 2014-10-20
  5  Error-less DDL commands
  6  
  7  Some database objects have a create or replace syntax.  While you're developing
  8  that can be quite handy because it allows you to easily create a re-runnable
  9  script.  This package adds a cuople of errorless drop commands that also make
 10  it easier to create a re-runnable script.
 11  */
 12  
 13  
 14  -- Drop the specified sequence if it exists.
 15  -- If it does not, report nothing, otherwise
 16  -- report the SQLERRM
 17  PROCEDURE dseq(
 18  aiv_sequence_name		    in	   varchar2);
 19  
 20  
 21  -- Drop the specified table if it exists.
 22  -- If it does not, report nothing, otherwise
 23  -- report the SQLERRM
 24  PROCEDURE dtab(
 25  aiv_table_name		    in	   varchar2);
 26  
 27  
 28  -- Drop the specified trigger if it exists.
 29  -- If it does not, report nothing, otherwise
 30  -- report the SQLERRM
 31  PROCEDURE dtrg(
 32  aiv_trigger_name		    in	   varchar2);
 33  
 34  
 35  end DDL_;
 36  /

Package created.

SQL> @se.sql
SQL> show errors
No errors.
SQL> @ddl_.pkb
SQL> create or replace package body DDL_ as
  2  /*
  3  ddl.pkb
  4  by Donald J. Bales on 2014-10-20
  5  Error-less DDL commands
  6  */
  7  
  8  
  9  PROCEDURE dseq(
 10  aiv_sequence_name		    in	   varchar2) is
 11  
 12  v_ddl				   varchar2(500);
 13  
 14  begin
 15    begin
 16  	 v_ddl := 'drop sequence '||aiv_sequence_name;
 17  
 18  	 execute immediate v_ddl;
 19  
 20  	 SYS.DBMS_OUTPUT.put_line('Sequence dropped.');
 21    exception
 22  	 when OTHERS then
 23  	   if SQLCODE = -2289 then
 24  	     SYS.DBMS_OUTPUT.put_line(substr(SQLERRM, instr(SQLERRM, ': ') + 2, 255));
 25  	   else
 26  	     SYS.DBMS_OUTPUT.put_line(SQLERRM);
 27  	   end if;
 28    end;
 29  end dseq;
 30  
 31  
 32  PROCEDURE dtab(
 33  aiv_table_name		    in	   varchar2) is
 34  
 35  v_ddl				   varchar2(500);
 36  
 37  begin
 38    begin
 39  	 v_ddl := 'drop table '||aiv_table_name;
 40  
 41  	 execute immediate v_ddl;
 42  
 43  	 SYS.DBMS_OUTPUT.put_line('Table dropped.');
 44    exception
 45  	 when OTHERS then
 46  	   if SQLCODE = -942 then
 47  	     SYS.DBMS_OUTPUT.put_line(substr(SQLERRM, instr(SQLERRM, ': ') + 2, 255));
 48  	   else
 49  	     SYS.DBMS_OUTPUT.put_line(SQLERRM);
 50  	   end if;
 51    end;
 52  end dtab;
 53  
 54  
 55  PROCEDURE dtrg(
 56  aiv_trigger_name		    in	   varchar2) is
 57  
 58  v_ddl				   varchar2(500);
 59  
 60  begin
 61    begin
 62  	 v_ddl := 'drop trigger '||aiv_trigger_name;
 63  
 64  	 execute immediate v_ddl;
 65  
 66  	 SYS.DBMS_OUTPUT.put_line('Trigger dropped.');
 67    exception
 68  	 when OTHERS then
 69  	   if SQLCODE = -4080 then
 70  	     SYS.DBMS_OUTPUT.put_line(substr(SQLERRM, instr(SQLERRM, ': ') + 2, 255));
 71  	   else
 72  	     SYS.DBMS_OUTPUT.put_line(SQLERRM);
 73  	   end if;
 74    end;
 75  end dtrg;
 76  
 77  
 78  end DDL_;
 79  /

Package body created.

SQL> @be.sql
SQL> show errors
No errors.
SQL> @pl.prc
SQL> create or replace PROCEDURE pl(
  2  aiv_text			    in	   varchar2 ) is
  3  /*
  4  pl.prc
  5  by Donald J. Bales on 2014-10-20
  6  A wrapper procedure for SYS.DBMS_OUTPUT.put_line()
  7  for the lazy typist.
  8  */
  9  
 10  begin
 11    SYS.DBMS_OUTPUT.put_line(aiv_text);
 12  end pl;
 13  /

Procedure created.

SQL> @pe.sql pl
SQL> show errors
No errors.
SQL> 
SQL> @date_.pks
SQL> create or replace package	    DATE_ as
  2  /*
  3  date_.pks
  4  by Donald J. Bales on 2014-10-20
  5  Additional DATE data type methods.
  6  */
  7  
  8  -- The maximum and minimum date_.values.
  9  
 10  d_MAX			  constant date :=
 11    to_date('99991231235959', 'YYYYMMDDHH24MISS');
 12  d_MIN			  constant date :=
 13    to_date('-47120101', 'SYYYYMMDD');
 14  
 15  
 16  -- Returns the specified date with the time set to 23:59:59, therefore,
 17  -- the end of the day.
 18  
 19  FUNCTION end_of_day(
 20  aid_date			    in	   date )
 21  return				   date;
 22  
 23  
 24  -- Returns constant d_MAX.  This is useful in SQL statements where the
 25  -- constant DATE_.d_MAX is not accessible.
 26  
 27  FUNCTION get_max
 28  return				   date;
 29  
 30  
 31  -- Returns constant d_MIN.  This is useful in SQL statements where the
 32  -- constant DATE_.d_MIN is not accessible.
 33  
 34  FUNCTION get_min
 35  return				   date;
 36  
 37  
 38  -- Text-based help for this package.  "set serveroutput on" in SQL*Plus.
 39  
 40  PROCEDURE help;
 41  
 42  
 43  -- Returns a randomly generated date that exists between the years specified.
 44  
 45  FUNCTION random(
 46  ain_starting_year		    in	   number,
 47  ain_ending_year		    in	   number )
 48  return				   date;
 49  
 50  
 51  -- Returns the specified date with the time set to 00:00:00, therefore, the
 52  -- start of the day.
 53  
 54  FUNCTION start_of_day(
 55  aid_date			    in	   date )
 56  return				   date;
 57  
 58  
 59  -- Test unit for this package.
 60  
 61  PROCEDURE test;
 62  
 63  
 64  end DATE_;
 65  /

Package created.

SQL> @se.sql DATE_
SQL> show errors
No errors.
SQL> @date_.pkb
SQL> create or replace package body DATE_ as
  2  /*
  3  date_.pkb
  4  by Donald J. Bales on 2014-10-20
  5  Additional DATE data type methods
  6  */
  7  
  8  
  9  FUNCTION end_of_day(
 10  aid_date			    in	   date )
 11  return				   date is
 12  
 13  begin
 14   return to_date(to_char(aid_date, 'SYYYYMMDD')||'235959',
 15  	'SYYYYMMDDHH24MISS');
 16  end end_of_day;
 17  
 18  
 19  FUNCTION get_max
 20  return				   date is
 21  
 22  begin
 23   return d_MAX;
 24  end get_max;
 25  
 26  
 27  FUNCTION get_min
 28  return				   date is
 29  
 30  begin
 31   return d_MIN;
 32  end get_min;
 33  
 34  
 35  FUNCTION random(
 36  ain_starting_year		    in	   number,
 37  ain_ending_year		    in	   number )
 38  return				   date is
 39  
 40  d_random				   date;
 41  n_day				   number;
 42  n_month				   number;
 43  n_year				   number;
 44  
 45  begin
 46    n_year	 := round(DBMS_RANDOM.value(
 47  	 ain_starting_year, ain_ending_year), 0);
 48    --pl('n_year='||n_year);
 49    loop
 50  	 n_month := round(DBMS_RANDOM.value(1, 12), 0);
 51  	 --pl('n_month='||n_month);
 52  	 n_day	 := round(DBMS_RANDOM.value(1, 31), 0);
 53  	 --pl('n_day='||n_day);
 54  	 begin
 55  	   d_random := to_date(lpad(to_char(n_year),  4, '0')||
 56  			       lpad(to_char(n_month), 2, '0')||
 57  			       lpad(to_char(n_day),   2, '0'),
 58  			       'YYYYMMDD');
 59  	   exit;
 60  	 exception
 61  	   when OTHERS then
 62  	     if SQLCODE <> -1839 then
 63  	       pl(SQLERRM);
 64  	     --else
 65  	     --  pl('29-31');
 66  	     end if;
 67  	 end;
 68    end loop;
 69    return d_random;
 70  end random;
 71  
 72  
 73  FUNCTION start_of_day(
 74  aid_date			    in	   date )
 75  return				   date is
 76  
 77  begin
 78   return trunc(aid_date);
 79  end start_of_day;
 80  
 81  
 82  -- Write up the help text here in this help method
 83  PROCEDURE help is
 84  
 85  begin
 86  --   1234567890123456789012345678901234567890123456789012345678901234567890
 87    pl('============================== PACKAGE ==============================');
 88    pl(chr(9));
 89    pl('DATE_');
 90    pl(chr(9));
 91    pl('------------------------------ CONSTANTS ----------------------------');
 92    pl(chr(9));
 93    pl('d_MAX');
 94    pl(chr(9)||'Represents the maximum value for the DATE data type.');
 95    pl('d_MIN');
 96    pl(chr(9)||'Represents the minimum value for the DATE data type.');
 97    pl(chr(9));
 98    pl('------------------------------ FUNCTIONS ----------------------------');
 99    pl(chr(9));
100    pl('DATE_.end_of_day(');
101    pl('aid_date			  in	 date)');
102    pl('return				 date;');
103    pl(chr(9)||'Returns the passed date with the time portion set to the end ');
104    pl(chr(9)||'of the day:');
105    pl(chr(9)||'23:59:59 (HH24:MI:SS).');
106    pl(chr(9));
107    pl('DATE_.get_max( )');
108    pl('return				 date;');
109    pl(chr(9)||'Returns the constant DATE_.d_MAX.');
110    pl(chr(9));
111    pl('DATE_.get_mim( )');
112    pl('return				 date;');
113    pl(chr(9)||'Returns the constant DATE_.d_MIN.');
114    pl(chr(9));
115    pl('DATE_.random(');
116    pl('ain_starting_year		  in	 number,');
117    pl('ain_ending_year		  in	 number)');
118    pl('return				 date;');
119    pl(chr(9)||'Returns a random date that exists between the specified years.');
120    pl(chr(9));
121    pl('DATE_.start_of_day(');
122    pl('aid_date			  in	 date)');
123    pl('return				 date;');
124    pl(chr(9)||'Returns the passed date with the time portion set to the start');
125    pl(chr(9)||'of the day:');
126    pl(chr(9)||'00:00:00 (HH24:MI:SS).');
127    pl(chr(9));
128    pl('------------------------------ PROCEDURES ----------------------------');
129    pl(chr(9));
130    pl('DATE_.help( );');
131    pl(chr(9)||'Displays this help text if set serveroutput is on.');
132    pl(chr(9));
133    pl('DATE_.test( );');
134    pl(chr(9)||'Built-in test unit.	It will report success or error for each');
135    pl(chr(9)||'test if set');
136    pl(chr(9)||'serveroutput is on.');
137    pl(chr(9));
138  end help;
139  
140  
141  PROCEDURE test is
142  
143  d_date				   date;
144  
145  begin
146    pl('============================== PACKAGE ===============================');
147    pl(chr(9));
148    pl('DATE_');
149    pl(chr(9));
150    pl('1. Testing constants d_MIN and d_MAX');
151    if d_MIN < d_MAX then
152  	pl('SUCCESS');
153    else
154  	pl('ERROR: d_MIN is not less than d_MAX');
155    end if;
156  
157    pl('2. Testing end_of_day()');
158    if to_char(end_of_day(SYSDATE), 'HH24MISS') = '235959' then
159  	pl('SUCCESS');
160    else
161  	pl('ERROR: end_of_day is not 23:59:59');
162    end if;
163  
164    pl('3. Testing get_max()');
165    if get_max() = d_MAX then
166  	pl('SUCCESS');
167    else
168  	pl('ERROR: get_max() is not equal to d_MAX');
169    end if;
170  
171    pl('4. Testing get_min()');
172    if get_min() = d_MIN then
173  	pl('SUCCESS');
174    else
175  	pl('ERROR: get_min() is not equal to d_MIN');
176    end if;
177  
178    pl('5. Testing random() 1000 times');
179    for i in 1..1000 loop
180  	 d_date := random(1, 9999);
181  	 --pl(to_char(d_date, 'YYYY-MM-DD HH24:MI:SS'));
182    end loop;
183    pl('SUCCESS');
184  
185    pl('6. Testing start_of_day()');
186    if to_char(start_of_day(SYSDATE), 'HH24MISS') = '000000' then
187  	pl('SUCCESS');
188    else
189  	pl('ERROR: start_of_day is not 00:00:00');
190    end if;
191  end test;
192  
193  
194  end DATE_;
195  /

Package body created.

SQL> @be.sql DATE_
SQL> show errors
No errors.
SQL> 
SQL> @gender_type.tps
SQL> create TYPE GENDER_TYPE as object (
  2  /*
  3  gender_type.tps
  4  by Don Bales on 2014-10-20
  5  Type GENDER's attributes and methods.
  6  */
  7  id 				   number,
  8  code				   varchar2(30),
  9  description			   varchar2(80),
 10  active_date			   date,
 11  inactive_date			   date,
 12  /*
 13  A constructor for creating a new instance of type GENDER_TYPE with NULL
 14  values.
 15  */
 16  CONSTRUCTOR FUNCTION gender_type(
 17  self			    in out gender_type)
 18  return				   self as result,
 19  /*
 20  A constructor for creating a new instance of type GENDER_TYPE for insert.
 21  */
 22  CONSTRUCTOR FUNCTION gender_type(
 23  self			    in out gender_type,
 24  aiv_code				   varchar2,
 25  aiv_description			   varchar2)
 26  return				   self as result,
 27  /*
 28  Gets the code and decription values for the specified id.
 29  */
 30  STATIC PROCEDURE get_code_descr(
 31  ain_id			    in	   number,
 32  aov_code			       out varchar2,
 33  aov_description		       out varchar2),
 34  /*
 35  Verifies that the passed code value is an exact or like match on the
 36  date specified.
 37  */
 38  STATIC PROCEDURE get_code_id_descr(
 39  aiov_code			    in out varchar2,
 40  aon_id			       out number,
 41  aov_description		       out varchar2,
 42  aid_on			    in	   date),
 43  /*
 44  Verifies that the passed code value is currently an exact or like match.
 45  */
 46  STATIC PROCEDURE get_code_id_descr(
 47  aiov_code			    in out varchar2,
 48  aon_id			       out number,
 49  aov_description		       out varchar2),
 50  /*
 51  Returns a new primary key id value for a row.
 52  */
 53  MEMBER FUNCTION get_id
 54  return				   number,
 55  /*
 56  Returns the id for the specified code value.
 57  */
 58  STATIC FUNCTION get_id(
 59  aiv_code			    in	   varchar2)
 60  return				   number,
 61  /*
 62  Test-based help for this package.	"set serveroutput on" in SQL*Plus.
 63  */
 64  STATIC PROCEDURE help,
 65  /*
 66  Test units for this package.
 67  */
 68  STATIC PROCEDURE test,
 69  /*
 70  A MAP function for sorting at the object level.
 71  */
 72  MAP MEMBER FUNCTION to_varchar2
 73  return				   varchar2
 74  );
 75  /

Type created.

SQL> @se.sql GENDER_TYPE
SQL> show errors
No errors.
SQL> @worker_type.tps
SQL> create TYPE WORKER_TYPE as object (
  2  /*
  3  worker_type.tps
  4  by Don Bales on 2014-10-20
  5  Type WORKER_TYPE's attributes and methods.
  6  */
  7  id 				   number,
  8  code				   varchar2(30),
  9  description			   varchar2(80),
 10  active_date			   date,
 11  inactive_date			   date,
 12  -- Gets the code and decription values for the specified work_type_id.
 13  STATIC PROCEDURE get_code_descr(
 14  ain_id			    in	   number,
 15  aov_code			       out varchar2,
 16  aov_description		       out varchar2 ),
 17  -- Verifies the passed aiov_code value is an exact or like match on the
 18  -- date specified.
 19  STATIC PROCEDURE get_code_id_descr(
 20  aiov_code			    in out varchar2,
 21  aon_id			       out number,
 22  aov_description		       out varchar2,
 23  aid_on			    in	   date ),
 24  -- Verifies the passed aiov_code value is currently an exact or like match.
 25  STATIC PROCEDURE get_code_id_descr(
 26  aiov_code			    in out varchar2,
 27  aon_id			       out number,
 28  aov_description		       out varchar2 ),
 29  -- Returns a newly allocated id value.
 30  MEMBER FUNCTION get_id
 31  return				   number,
 32  -- Returns the id for the specified code value.
 33  STATIC FUNCTION get_id(
 34  aiv_code			    in	   varchar2 )
 35  return				   number,
 36  -- Test-based help for this package.  "set serveroutput on" in SQL*Plus.
 37  STATIC PROCEDURE help,
 38  -- Test units for this package.
 39  STATIC PROCEDURE test,
 40  -- A MAP function for sorting at the object level.
 41  MAP MEMBER FUNCTION to_varchar2
 42  return				   varchar2,
 43  -- A constructor for creating a new instance of type WORKER_TYPE
 44  -- with NULL values.
 45  CONSTRUCTOR FUNCTION worker_type(
 46  self			    in out worker_type)
 47  return				   self as result,
 48  -- A constructor for creating a new instance of type WORKER_TYPE
 49  -- for insert.
 50  CONSTRUCTOR FUNCTION worker_type(
 51  self			    in out worker_type,
 52  aiv_code			    in	   varchar2,
 53  aiv_description		    in	   varchar2)
 54  return				   self as result
 55  );
 56  /

Type created.

SQL> @se.sql WORKER_TYPE
SQL> show errors
No errors.
SQL> @worker.tps
SQL> create type WORKER as object (
  2  /*
  3  worker.tps
  4  by Don Bales on 2014-10-20
  5  Type WORKER's attributes and methods.
  6  */
  7  id 				   number(38),
  8  worker_type_id			   number(38),
  9  external_id			   varchar2(30),
 10  first_name 			   varchar2(30),
 11  middle_name			   varchar2(30),
 12  last_name				   varchar2(30),
 13  name				   varchar2(100),
 14  birth_date 			   date,
 15  gender_type_id			   number(38),
 16  /*
 17  Get the worker's current age.
 18  */
 19  MEMBER FUNCTION get_age
 20  return				   number,
 21  /*
 22  Get the worker's age on the specified date.
 23  */
 24  MEMBER FUNCTION get_age(
 25  aid_on				   date)
 26  return				   number,
 27  /*
 28  Calculate a worker's age for the given birth date
 29  and point in time.
 30  */
 31  STATIC FUNCTION get_age(
 32  aid_birth_date		    in	   date,
 33  aid_on			    in	   date)
 34  return				   number,
 35  /*
 36  Calculate a worker's current age for the given bith date.
 37  */
 38  STATIC FUNCTION get_age(
 39  aid_birth_date		    in	   date)
 40  return				   number,
 41  /*
 42  Get the specified worker's age at the given point in time.
 43  */
 44  STATIC FUNCTION get_age(
 45  ain_id			    in	   number,
 46  aid_on			    in	   date)
 47  return				   number,
 48  /*
 49  Get the specified worker's current age.
 50  */
 51  STATIC FUNCTION get_age(
 52  ain_id			    in	   number)
 53  return				   number,
 54  /*
 55  Get the specified worker's birth date.
 56  */
 57  STATIC FUNCTION get_birth_date(
 58  ain_id			    in	   number)
 59  return				   date,
 60  /*
 61  Get the specified worker's external ID.
 62  */
 63  STATIC FUNCTION get_external_id
 64  return				   varchar2,
 65  /*
 66  Calculate the locale specific formatted name.
 67  */
 68  STATIC FUNCTION get_formatted_name(
 69  aiv_first_name		    in	   varchar2,
 70  aiv_middle_name		    in	   varchar2,
 71  aiv_last_name		    in	   varchar2)
 72  return				   varchar2,
 73  /*
 74  Get the specified worker's formatted name.
 75  */
 76  STATIC FUNCTION get_formatted_name(
 77  ain_id			    in	   number)
 78  return				   varchar2,
 79  /*
 80  Get the next primary key value for the table.
 81  */
 82  STATIC FUNCTION get_id
 83  return				   number,
 84  /*
 85  Get the specified worker's internal ID.
 86  */
 87  STATIC FUNCTION get_id(
 88  aiv_external_id		    in	   varchar2)
 89  return				   number,
 90  /*
 91  Get the specified worker's row object.
 92  */
 93  STATIC FUNCTION get_row(
 94  aio_worker 		    in	   WORKER)
 95  return				   WORKER,
 96  /*
 97  Calculate the non-locale specific unformmated name.
 98  */
 99  STATIC FUNCTION get_unformatted_name(
100  aiv_first_name		    in	   varchar2,
101  aiv_middle_name		    in	   varchar2,
102  aiv_last_name		    in	   varchar2)
103  return				   varchar2,
104  /*
105  Display the help text for this TYPE.
106  */
107  MEMBER PROCEDURE help,
108  /*
109  Check to see if a worker with the same name, birth_date and
110  gender already exists in the database.
111  */
112  STATIC FUNCTION is_duplicate(
113  aiv_name			    in	   varchar2,
114  aid_birth_date		    in	   varchar2,
115  ain_gender_type_id 	    in	   varchar2)
116  return				   boolean,
117  /*
118  Set the specified worker's row object.
119  */
120  STATIC PROCEDURE set_row(
121  aioo_worker		    in out WORKER),
122  /*
123  Execute the test unit for this TYPE.
124  */
125  MEMBER PROCEDURE test,
126  /*
127  The MAP function for this TYPE.
128  */
129  MAP MEMBER FUNCTION to_varchar2
130  return				   varchar2,
131  /*
132  A convenience constructor for this TYPE.
133  */
134  CONSTRUCTOR FUNCTION worker(
135  self			    in out worker,
136  ain_worker_type_id 	    in	   number,
137  aiv_first_name		    in	   varchar2,
138  aiv_middle_name		    in	   varchar2,
139  aiv_last_name		    in	   varchar2,
140  aid_birth_date		    in	   date,
141  ain_gender_type_id 	    in	   number)
142  return				   self as result,
143  /*
144  A NULL values constructor for this TYPE.
145  */
146  CONSTRUCTOR FUNCTION worker(
147  self			    in out worker)
148  return				   self as result
149  );
150  /

Type created.

SQL> @se.sql
SQL> show errors
No errors.
SQL> 
SQL> @gender_types.tab
SQL> rem gender_types.tab
SQL> rem by Donald J. Bales on 2014-10-20
SQL> rem Create an object table for the Gender Type codes
SQL> 
SQL> --drop   table GENDER_TYPES;
SQL> create table GENDER_TYPES of GENDER_TYPE;

Table created.

SQL> 
SQL> --drop   sequence GENDERS_ID;
SQL> create sequence GENDERS_ID
  2  start with 1;

Sequence created.

SQL> 
SQL> alter  table GENDER_TYPES add
  2  constraint   GENDER_TYPES_PK
  3  primary key ( id )
  4  using index;

Table altered.

SQL> 
SQL> alter  table GENDER_TYPES add
  2  constraint   GENDER_TYPES_UK
  3  unique ( code, active_date )
  4  using index;

Table altered.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'GENDER_TYPES');

PL/SQL procedure successfully completed.

SQL> @worker_types.tab
SQL> rem worker_type.tab
SQL> rem copyright by Donald J. Bales on 2014-10-20
SQL> rem Create an object table for the Worker Type codes
SQL> 
SQL> --drop   table WORKER_TYPES;
SQL> create table WORKER_TYPES of WORKER_TYPE;

Table created.

SQL> 
SQL> --drop   sequence WORKER_TYPES_ID;
SQL> create sequence WORKER_TYPES_ID
  2  start with 1;

Sequence created.

SQL> 
SQL> alter  table WORKER_TYPES add
  2  constraint   WORKER_TYPES_PK
  3  primary key ( id )
  4  using index;

Table altered.

SQL> 
SQL> alter  table WORKER_TYPES add
  2  constraint   WORKER_TYPES_UK
  3  unique ( code )
  4  using index;

Table altered.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'WORKER_TYPES');

PL/SQL procedure successfully completed.

SQL> @workers.tab
SQL> rem worker_ot.tab
SQL> rem by Donald J. Bales on 2014-10-20
SQL> rem Create an object table for Workers
SQL> 
SQL> --drop   table WORKERS;
SQL> create table WORKERS of WORKER;

Table created.

SQL> 
SQL> --drop   sequence WORKERS_ID;
SQL> create sequence WORKERS_ID
  2  start with 1;

Sequence created.

SQL> 
SQL> --drop   sequence EXTERNAL_ID_SEQ;
SQL> create sequence EXTERNAL_ID_SEQ
  2  start with 100000000 order;

Sequence created.

SQL> 
SQL> alter  table WORKERS add
  2  constraint   WORKERS_PK
  3  primary key ( id )
  4  using index;

Table altered.

SQL> 
SQL> alter  table WORKERS add
  2  constraint   WORKERS_UK1
  3  unique ( external_id )
  4  using index;

Table altered.

SQL> 
SQL> alter  table WORKERS add
  2  constraint   WORKERS_UK2
  3  unique (
  4  name,
  5  birth_date,
  6  gender_type_id )
  7  using index;

Table altered.

SQL> 
SQL> alter  table WORKERS add
  2  constraint   WORKERS_FK1
  3  foreign key   ( worker_type_id )
  4  references   WORKER_TYPES ( id );

Table altered.

SQL> 
SQL> alter  table WORKERS add
  2  constraint   WORKERS_FK2
  3  foreign key   ( gender_type_id )
  4  references   GENDER_TYPES ( id );

Table altered.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'WORKERS');

PL/SQL procedure successfully completed.

SQL> 
SQL> @gender_type.tpb
SQL> create or replace TYPE BODY GENDER_TYPE as
  2  /*
  3  gender_type.tpb
  4  by Don Bales on 2014-10-20
  5  Type GENDER_TYPE's attributes and methods
  6  */
  7  
  8  CONSTRUCTOR FUNCTION gender_type(
  9  self			    in out gender_type)
 10  return				   self as result is
 11  
 12  begin
 13    id	     := NULL;
 14    code	     := NULL;
 15    description   := NULL;
 16    active_date   := NULL;
 17    inactive_date := NULL;
 18    return;
 19  end gender_type;
 20  
 21  
 22  CONSTRUCTOR FUNCTION gender_type(
 23  self			    in out gender_type,
 24  aiv_code				   varchar2,
 25  aiv_description			   varchar2)
 26  return				   self as result is
 27  
 28  begin
 29    id	     := get_id();
 30    code	     := aiv_code;
 31    description   := aiv_description;
 32    active_date   := SYSDATE;
 33    inactive_date := DATE_.d_MAX;
 34    return;
 35  end gender_type;
 36  
 37  
 38  STATIC PROCEDURE get_code_descr(
 39  ain_id			    in	   number,
 40  aov_code			       out varchar2,
 41  aov_description		       out varchar2 ) is
 42  
 43  begin
 44    select code,
 45  	      description
 46    into   aov_code,
 47  	      aov_description
 48    from   GENDER_TYPES
 49    where  id = ain_id;
 50  end get_code_descr;
 51  
 52  
 53  STATIC PROCEDURE get_code_id_descr(
 54  aiov_code			    in out varchar2,
 55  aon_id			       out number,
 56  aov_description		       out varchar2,
 57  aid_on			    in	   date ) is
 58  
 59  v_code				   varchar2(30);
 60  
 61  begin
 62    select id,
 63  	      description
 64    into   aon_id,
 65  	      aov_description
 66    from   GENDER_TYPES
 67    where  code = aiov_code
 68    and    aid_on between active_date and nvl(inactive_date, DATE_.d_MAX);
 69  exception
 70    when NO_DATA_FOUND then
 71  	 select id,
 72  		code,
 73  		description
 74  	 into	aon_id,
 75  		v_code,
 76  		aov_description
 77  	 from	GENDER_TYPES
 78  	 where	code like aiov_code||'%'
 79  	 and	aid_on between active_date and nvl(inactive_date, DATE_.d_MAX);
 80  	 aiov_code := v_code;
 81  end get_code_id_descr;
 82  
 83  
 84  STATIC PROCEDURE get_code_id_descr(
 85  aiov_code			    in out varchar2,
 86  aon_id			       out number,
 87  aov_description		       out varchar2 ) is
 88  
 89  begin
 90   get_code_id_descr(
 91    aiov_code,
 92    aon_id,
 93    aov_description,
 94    SYSDATE );
 95  end get_code_id_descr;
 96  
 97  
 98  MEMBER FUNCTION get_id
 99  return				   number is
100  
101  n_id				   number;
102  
103  begin
104    select GENDERS_ID.nextval
105    into   n_id
106    from   SYS.DUAL;
107  
108    return n_id;
109  end get_id;
110  
111  
112  STATIC FUNCTION get_id(
113  aiv_code			    in	   varchar2 )
114  return				   number is
115  
116  n_id				   number;
117  
118  begin
119    select id
120    into   n_id
121    from   GENDER_TYPES
122    where  code = aiv_code;
123  
124    return n_id;
125  end get_id;
126  
127  
128  STATIC PROCEDURE help is
129  
130  begin
131   pl('No help at this time.');
132  end help;
133  
134  
135  STATIC PROCEDURE test is
136  
137  begin
138    pl('No tests coded at this time');
139  end test;
140  
141  
142  MAP MEMBER FUNCTION to_varchar2
143  return				   varchar2 is
144  
145  begin
146    return description||to_char(active_date, 'YYYYMMDDHH24MISS');
147  end to_varchar2;
148  
149  
150  end;
151  /

Type body created.

SQL> @be.sql GENDER_TYPE
SQL> show errors
No errors.
SQL> @worker_type.tpb
SQL> create or replace TYPE BODY WORKER_TYPE as
  2  /*
  3  worker_type.tpb
  4  by Don Bales on 2014-10-20
  5  Type WORKER_TYPE's methods
  6  */
  7  
  8  
  9  MEMBER FUNCTION get_id
 10  return				   number is
 11  
 12  n_id				   number;
 13  
 14  begin
 15    select WORKER_TYPES_ID.nextval
 16    into   n_id
 17    from   SYS.DUAL;
 18  
 19    return n_id;
 20  end get_id;
 21  
 22  
 23  STATIC FUNCTION get_id(
 24  aiv_code			    in	   varchar2 )
 25  return				   number is
 26  
 27  n_id				   number;
 28  
 29  begin
 30    select id
 31    into   n_id
 32    from   WORKER_TYPES
 33    where  code = aiv_code;
 34  
 35    return n_id;
 36  end get_id;
 37  
 38  
 39  STATIC PROCEDURE get_code_descr(
 40  ain_id			    in	   number,
 41  aov_code			       out varchar2,
 42  aov_description		       out varchar2 ) is
 43  
 44  begin
 45    select code,
 46  	      description
 47    into   aov_code,
 48  	      aov_description
 49    from   WORKER_TYPES
 50    where  id = ain_id;
 51  end get_code_descr;
 52  
 53  
 54  STATIC PROCEDURE get_code_id_descr(
 55  aiov_code			    in out varchar2,
 56  aon_id			       out number,
 57  aov_description		       out varchar2,
 58  aid_on			    in	   date ) is
 59  
 60  v_code				   varchar2(30);
 61  
 62  begin
 63    select id,
 64  	      description
 65    into   aon_id,
 66  	      aov_description
 67    from   WORKER_TYPES
 68    where  code = aiov_code
 69    and    aid_on between active_date and nvl(inactive_date, DATE_.d_MAX);
 70  exception
 71    when NO_DATA_FOUND then
 72  	 select id,
 73  		code,
 74  		description
 75  	 into	aon_id,
 76  		v_code,
 77  		aov_description
 78  	 from	WORKER_TYPES
 79  	 where	code like aiov_code||'%'
 80  	 and	aid_on between active_date and nvl(inactive_date, DATE_.d_MAX);
 81  
 82  	 aiov_code := v_code;
 83  end get_code_id_descr;
 84  
 85  
 86  STATIC PROCEDURE get_code_id_descr(
 87  aiov_code			    in out varchar2,
 88  aon_id			       out number,
 89  aov_description		       out varchar2 ) is
 90  
 91  begin
 92   get_code_id_descr(
 93    aiov_code,
 94    aon_id,
 95    aov_description,
 96    SYSDATE );
 97  end get_code_id_descr;
 98  
 99  
100  STATIC PROCEDURE help is
101  
102  begin
103   pl('No help coded at this time.');
104  end help;
105  
106  
107  STATIC PROCEDURE test is
108  
109  begin
110    pl('No tests coded at this time.');
111  end test;
112  
113  
114  MAP MEMBER FUNCTION to_varchar2
115  return				   varchar2 is
116  
117  begin
118    return description||to_char(active_date, 'YYYYMMDDHH24MISS');
119  end to_varchar2;
120  
121  
122  CONSTRUCTOR FUNCTION worker_type(
123  self			    in out worker_type)
124  return				   self as result is
125  
126  begin
127    id	     := NULL;
128    code	     := NULL;
129    description   := NULL;
130    active_date   := NULL;
131    inactive_date := NULL;
132    return;
133  end worker_type;
134  
135  
136  CONSTRUCTOR FUNCTION worker_type(
137  self			    in out worker_type,
138  aiv_code			    in	   varchar2,
139  aiv_description		    in	   varchar2)
140  return				   self as result is
141  
142  begin
143    id	     := get_id();
144    code	     := aiv_code;
145    description   := aiv_description;
146    active_date   := SYSDATE;
147    inactive_date := DATE_.d_MAX;
148    return;
149  end worker_type;
150  
151  
152  end;
153  /

Type body created.

SQL> @be.sql WORKER_TYPE
SQL> show errors
No errors.
SQL> @worker.tpb
SQL> create or replace type body WORKER as
  2  /*
  3  worker.tpb
  4  by Don Bales on 2014-10-20
  5  TYPE WORKER's methods
  6  */
  7  
  8  MEMBER FUNCTION get_age(
  9  aid_on			    in	   date)
 10  return				   number is
 11  
 12  begin
 13    return WORKER.get_age(birth_date, aid_on);
 14  end get_age;
 15  
 16  
 17  MEMBER FUNCTION get_age
 18  return				   number is
 19  
 20  begin
 21    return WORKER.get_age(birth_date, SYSDATE);
 22  end get_age;
 23  
 24  
 25  STATIC FUNCTION get_age(
 26  aid_birth_date		    in	   date,
 27  aid_on			    in	   date)
 28  return				   number is
 29  
 30  begin
 31   if aid_birth_date is not NULL and
 32  	 aid_on 	is not NULL then
 33  	return trunc(months_between(aid_on, aid_birth_date) / 12);
 34   else
 35  	return NULL;
 36   end if;
 37  exception
 38   when OTHERS then
 39  	return NULL;
 40  end get_age;
 41  
 42  
 43  STATIC FUNCTION get_age(
 44  aid_birth_date		    in	   date)
 45  return				   number is
 46  
 47  begin
 48    return WORKER.get_age(aid_birth_date, SYSDATE);
 49  end get_age;
 50  
 51  
 52  STATIC FUNCTION get_age(
 53  ain_id			    in	   number,
 54  aid_on			    in	   date)
 55  return				   number is
 56  
 57  begin
 58    return WORKER.get_age(WORKER.get_birth_date(ain_id), aid_on);
 59  end get_age;
 60  
 61  
 62  STATIC FUNCTION get_age(
 63  ain_id			    in	   number)
 64  return				   number is
 65  
 66  begin
 67    return WORKER.get_age(WORKER.get_birth_date(ain_id));
 68  end get_age;
 69  
 70  
 71  STATIC FUNCTION get_birth_date(
 72  ain_id			    in	   number)
 73  return				   date is
 74  
 75  d_birth_date			   date;
 76  
 77  begin
 78    select birth_date
 79    into   d_birth_date
 80    from   WORKERS
 81    where  id = ain_id;
 82  
 83    return d_birth_date;
 84  end get_birth_date;
 85  
 86  
 87  STATIC FUNCTION get_external_id
 88  return				   varchar2 is
 89  
 90  v_external_id			   varchar2(30);
 91  
 92  begin
 93    select lpad(to_char(EXTERNAL_ID_SEQ.nextval), 9, '0')
 94    into   v_external_id
 95    from   SYS.DUAL;
 96  
 97    return v_external_id;
 98  end get_external_id;
 99  
100  
101  STATIC FUNCTION get_id
102  return				   number is
103  
104  n_id				   number;
105  
106  begin
107    select WORKERS_ID.nextval
108    into   n_id
109    from   SYS.DUAL;
110  
111    return n_id;
112  end get_id;
113  
114  
115  STATIC FUNCTION get_id(
116  aiv_external_id		    in	   varchar2)
117  return				   number is
118  
119  n_id				   number;
120  
121  begin
122    select id
123    into   n_id
124    from   WORKERS
125    where  external_id = aiv_external_id;
126  
127    return n_id;
128  end get_id;
129  
130  
131  STATIC FUNCTION get_formatted_name(
132  aiv_first_name		    in	   varchar2,
133  aiv_middle_name		    in	   varchar2,
134  aiv_last_name		    in	   varchar2)
135  return				   varchar2 is
136  
137  begin
138   return aiv_last_name||', '||aiv_first_name||' '||aiv_middle_name;
139  end get_formatted_name;
140  
141  
142  STATIC FUNCTION get_formatted_name(
143  ain_id			    in	   number)
144  return				   varchar2 is
145  
146  v_first_name			   varchar2(30);
147  v_middle_name			   varchar2(30);
148  v_last_name			   varchar2(30);
149  
150  begin
151    select first_name,
152  	      middle_name,
153  	      last_name
154    into   v_first_name,
155  	      v_middle_name,
156  	      v_last_name
157    from   WORKERS
158    where  id = ain_id;
159  
160    return get_formatted_name(
161  	       v_first_name,
162  	       v_middle_name,
163  	       v_last_name);
164  end get_formatted_name;
165  
166  
167  STATIC FUNCTION get_row(
168  aio_worker 		    in	   WORKER)
169  return				   WORKER is
170  
171  o_worker				   WORKER;
172  
173  begin
174    if    aio_worker.id is not NULL then
175  	 -- retrieve the row by the primary key
176  	 select value(w)
177  	 into	o_worker
178  	 from	WORKERS w
179  	 where	id = aio_worker.id;
180    elsif aio_worker.external_id is not NULL then
181  	 -- retrieve the row by the external unique key
182  	 select value(w)
183  	 into	o_worker
184  	 from	WORKERS w
185  	 where	external_id = aio_worker.external_id;
186    else
187  	 -- retrieve the row by the name, birth_date, and gender
188  	 select value(w)
189  	 into	o_worker
190  	 from	WORKERS w
191  	 where	name	   = worker.get_formatted_name(
192  			       aio_worker.first_name,
193  			       aio_worker.middle_name,
194  			       aio_worker.last_name)
195  	 and	birth_date = aio_worker.birth_date
196  	 and	gender_type_id	= aio_worker.gender_type_id;
197    end if;
198    return o_worker;
199  exception
200    when NO_DATA_FOUND then
201  	 raise;
202    when OTHERS then
203  	 raise_application_error(-20001, SQLERRM||
204  	   ' on select WORKERS'||
205  	   ' in WORKER.get_row()');
206  end get_row;
207  
208  
209  STATIC FUNCTION get_unformatted_name(
210  aiv_first_name		    in	   varchar2,
211  aiv_middle_name		    in	   varchar2,
212  aiv_last_name		    in	   varchar2)
213  return				   varchar2 is
214  
215  begin
216    return upper(replace(replace(replace(replace(replace(
217  	 aiv_last_name||aiv_first_name||aiv_middle_name,
218  	   '''', NULL), ',', NULL), '-', NULL), '.', NULL), ' ', NULL));
219  end get_unformatted_name;
220  
221  
222  STATIC FUNCTION is_duplicate(
223  aiv_name			    in	   varchar2,
224  aid_birth_date		    in	   varchar2,
225  ain_gender_type_id 		 in	varchar2)
226  return				   boolean is
227  
228  n_selected 			   number;
229  
230  begin
231    execute immediate
232  	'select count(1)
233  	 from	WORKERS
234  	 where	name	   = aiv_name
235  	 and	birth_date = aid_birth_date
236  	 and	gender_type_id	= ain_gender_type_id'
237  	 into	n_selected
238  	 using	in aiv_name,
239  		in aid_birth_date,
240  		in ain_gender_type_id;
241  
242    if nvl(n_selected, 0) > 0 then
243  	 return TRUE;
244    else
245  	 return FALSE;
246    end if;
247  end is_duplicate;
248  
249  
250  MEMBER PROCEDURE help is
251  
252  begin
253  --   12345678901234567890123456789012345678901234567890123456789012345678901234567890
254    pl('=================================== PACKAGE ====================================');
255    pl(chr(9));
256    pl('WORKER');
257    pl(chr(9));
258    pl('----------------------------------- FUNCTIONS ----------------------------------');
259    pl(chr(9));
260    pl('YOU GOTTA CODE THIS BUDDY WORKER.get_id');
261    pl('return				 number;');
262    pl(chr(9)||'Returns a newly allocated sequence value for id.');
263    pl(chr(9));
264    pl('WORKER.get_id(');
265    pl('aiv_external_id		  in	 varchar2 )');
266    pl('return				 number;');
267    pl(chr(9)||'Returns the corresponding id for the specified external_id.');
268    pl(chr(9));
269    pl('----------------------------------- PROCEDURES ---------------------------------');
270    pl(chr(9));
271    pl('WORKER.get_external_id_descr(');
272    pl('ain_id			  in	 number,');
273    pl('aov_external_id		     out varchar2,');
274    pl('aov_description		     out WORKERS.description%TYPE );');
275    pl(chr(9)||'Gets the corresponding external_id and description for the specified');
276    pl(chr(9)||'id.');
277    pl(chr(9));
278    pl('WORKER.get_external_id_id_descr(');
279    pl('aiov_external_id			 in out varchar2,');
280    pl('aon_id		 out number,');
281    pl('aov_description		     out WORKERS.description%TYPE,');
282    pl('aid_on			  in	 WORKERS.active%TYPE );');
283    pl(chr(9)||'Gets the corresponding external_id, id, and description for');
284    pl(chr(9)||'the specified external_id.  First it trys to find an exact match.  If one');
285    pl(chr(9)||'cannot be found, it trys to find a like match.  It may throw a');
286    pl(chr(9)||'NO_DATA_FOUND or a TOO_MANY_ROWS exception if a match cannot be');
287    pl(chr(9)||'found for the specified external_id and point in time.');
288    pl(chr(9));
289    pl('WORKER.get_external_id_id_descr(');
290    pl('aiov_external_id		  in out varchar2,');
291    pl('aon_id			     out number,');
292    pl('aov_description		     out WORKERS.description%TYPE );');
293    pl(chr(9)||'Gets the corresponding external_id, id, and description for');
294    pl(chr(9)||'the specified external_id.  First it trys to find an exact match.  If one');
295    pl(chr(9)||'cannot be found, it trys to find a like match.  It may throw a');
296    pl(chr(9)||'NO_DATA_FOUND or a TOO_MANY_ROWS exception if a match cannot be');
297    pl(chr(9)||'found for the specified external_id at the current point in time.');
298    pl(chr(9));
299    pl('WORKER.help( );');
300    pl(chr(9)||'Displays this help text if set serveroutput is on.');
301    pl(chr(9));
302    pl('WORKER.test( );');
303    pl(chr(9)||'Built-in test unit.	It will report success or error for each test if set');
304    pl(chr(9)||'serveroutput is on.');
305    pl(chr(9));
306  end help;
307  
308  
309  STATIC PROCEDURE set_row(
310  aioo_worker		    in out WORKER) is
311  
312  d_null			  constant date        := DATE_.d_MIN;
313  n_null			  constant number      := 0;
314  v_null			  constant varchar2(1) := ' ';
315  o_worker				   WORKER;
316  
317  begin
318    -- set the formatted name
319    aioo_worker.name := worker.get_formatted_name(
320  			     aioo_worker.first_name,
321  			     aioo_worker.middle_name,
322  			     aioo_worker.last_name);
323    -- get the existing row
324    begin
325  	 o_worker := get_row(aioo_worker);
326    exception
327  	 when NO_DATA_FOUND then
328  	   o_worker := NULL;
329    end;
330    -- if a row exists, update it if needed
331    if o_worker is not NULL then
332  	 aioo_worker.id := o_worker.id;
333  	 if nvl(o_worker.worker_type_id, n_null) <>
334  	      nvl(aioo_worker.worker_type_id, n_null) or
335  	    nvl(o_worker.external_id,	 n_null) <>
336  	      nvl(aioo_worker.external_id,    n_null) or
337  	    nvl(o_worker.first_name,	 v_null) <>
338  	      nvl(aioo_worker.first_name,     v_null) or
339  	    nvl(o_worker.middle_name,	 v_null) <>
340  	      nvl(aioo_worker.middle_name,    v_null) or
341  	    nvl(o_worker.last_name,	 v_null) <>
342  	      nvl(aioo_worker.last_name,      v_null) or
343  	    nvl(o_worker.birth_date,	 d_null) <>
344  	      nvl(aioo_worker.birth_date,     d_null) or
345  	    nvl(o_worker.gender_type_id,      n_null) <>
346  	      nvl(aioo_worker.gender_type_id,	   n_null) then
347  	   begin
348  	     update WORKERS
349  	     set    worker_type_id = aioo_worker.worker_type_id,
350  		    external_id    = aioo_worker.external_id,
351  		    first_name	   = aioo_worker.first_name,
352  		    middle_name    = aioo_worker.middle_name,
353  		    last_name	   = aioo_worker.last_name,
354  		    name	   = aioo_worker.name,
355  		    birth_date	   = aioo_worker.birth_date,
356  		    gender_type_id = aioo_worker.gender_type_id
357  	     where  id		   = aioo_worker.id;
358  
359  --        n_updated := nvl(n_updated, 0) + nvl(sql%rowcount, 0);
360  	   exception
361  	     when OTHERS then
362  	       raise_application_error( -20002, SQLERRM||
363  		 ' on update WORKERS'||
364  		 ' in WORKER.set_row()' );
365  	   end;
366  	 end if;
367    else
368    -- add the row if it does not exist
369  	 begin
370  	   aioo_worker.id := get_id();
371  	   insert into WORKERS
372  	   values ( aioo_worker );
373  
374  --      n_inserted := nvl(n_inserted, 0) + nvl(sql%rowcount, 0);
375  	 exception
376  	   when OTHERS then
377  	     raise_application_error( -20003, SQLERRM||
378  	       ' on insert WORKERS'||
379  	       ' in WORKER.set_row()' );
380  	 end;
381    end if;
382  end set_row;
383  
384  
385  MEMBER PROCEDURE test(
386  self			    in out nocopy worker) is
387  
388  begin
389    pl('=================================== PACKAGE ====================================');
390    pl(chr(9));
391    pl('WORKER');
392    pl(chr(9));
393    pl(chr(9)||'No tests for WORKER at this time');
394  end test;
395  
396  
397  MAP MEMBER FUNCTION to_varchar2
398  return				   varchar2 is
399  
400  begin
401    return rtrim(name||to_char(birth_date, 'YYYYMMDDHH24MISS'));
402  end to_varchar2;
403  
404  
405  CONSTRUCTOR FUNCTION worker(
406  self			    in out worker,
407  ain_worker_type_id 	    in	   number,
408  aiv_first_name		    in	   varchar2,
409  aiv_middle_name		    in	   varchar2,
410  aiv_last_name		    in	   varchar2,
411  aid_birth_date		    in	   date,
412  ain_gender_type_id 	    in	   number)
413  return				   self as result is
414  
415  begin
416    id	      := WORKER.get_id();
417    worker_type_id := ain_worker_type_id;
418    external_id    := WORKER.get_external_id();
419    first_name     := aiv_first_name;
420    middle_name    := aiv_middle_name;
421    last_name      := aiv_last_name;
422    name	      := WORKER.get_formatted_name(
423  	 first_name, middle_name, last_name);
424    birth_date     := aid_birth_date;
425    gender_type_id := ain_gender_type_id;
426    return;
427  end worker;
428  
429  
430  CONSTRUCTOR FUNCTION worker(
431  self			    in out worker)
432  return				   self as result is
433  
434  begin
435    id	      := NULL;
436    worker_type_id := NULL;
437    external_id    := NULL;
438    first_name     := NULL;
439    middle_name    := NULL;
440    last_name      := NULL;
441    name	      := NULL;
442    birth_date     := NULL;
443    gender_type_id := NULL;
444    return;
445  end worker;
446  
447  
448  end; --WORKER;
449  /

Type body created.

SQL> @be.sql WORKER
SQL> show errors
No errors.
SQL> 
SQL> 
SQL> @gender_types.ins
SQL> rem gender_types.ins
SQL> rem copyright by Donald J. Bales on 2014-10-20
SQL> rem
SQL> 
SQL> insert into GENDER_TYPES values ( gender_type( 'F', 'Female' ) );

1 row created.

SQL> insert into GENDER_TYPES values ( gender_type( 'M', 'Male' ) );

1 row created.

SQL> insert into GENDER_TYPES values ( gender_type( 'U', 'Unknown' ) );

1 row created.

SQL> commit;

Commit complete.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'GENDER_TYPES');

PL/SQL procedure successfully completed.

SQL> @worker_types.ins
SQL> rem worker_typet.ins
SQL> rem copyright by Donald J. Bales on 2014-10-20
SQL> rem
SQL> 
SQL> insert into WORKER_TYPES values ( worker_type( 'C', 'Contractor' ) );

1 row created.

SQL> insert into WORKER_TYPES values ( worker_type( 'E', 'Employee' ) );

1 row created.

SQL> insert into WORKER_TYPES values ( worker_type( 'U', 'Unknown' ) );

1 row created.

SQL> commit;

Commit complete.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'WORKER_TYPES');

PL/SQL procedure successfully completed.

SQL> @workers.ins
SQL> rem workers.ins
SQL> rem by Donald J. Bales on 2014-10-20
SQL> rem Seed the Worker table with the top 100 names
SQL> rem 100 last x 100 first x 26 middle = 260,000 entries
SQL> 
SQL> set serveroutput on size 1000000;
SQL> 
SQL> declare
  2  
  3  -- This is the number of seconds since midnight
  4  -- I'll use it to profile my code's performance.
  5  n_start				   number :=
  6    to_number(to_char(SYSDATE, 'SSSSS'));
  7  
  8  -- Here, I declare four psuedo-constants to hold the
  9  -- ID values from the code tables, rather than look
 10  -- them up repeatedly during the insert process.
 11  n_G_FEMALE 			   GENDER_TYPES.id%TYPE;
 12  n_G_MALE				   GENDER_TYPES.id%TYPE;
 13  n_WT_CONTRACTOR			   WORKER_TYPES.id%TYPE;
 14  n_WT_EMPLOYEE			   WORKER_TYPES.id%TYPE;
 15  
 16  -- I'll use this to keep track of the number of
 17  -- rows inserted.
 18  n_inserted 			   number := 0;
 19  
 20  begin
 21    -- Get the ID values for the codes
 22    n_G_FEMALE      := GENDER_TYPE.get_id('F');
 23    n_G_MALE        := GENDER_TYPE.get_id('M');
 24    n_WT_CONTRACTOR := WORKER_TYPE.get_id('C');
 25    n_WT_EMPLOYEE   := WORKER_TYPE.get_id('E');
 26  
 27    -- Use an INSERT INTO SELECT SQL statement
 28    insert into WORKERS
 29    select WORKER(
 30  	      WORKERS_ID.nextval,
 31  	      decode(mod(WORKERS_ID.currval, 2),
 32  		0, n_WT_EMPLOYEE, n_WT_CONTRACTOR),
 33  	      lpad(to_char(EXTERNAL_ID_SEQ.nextval), 9, '0'),
 34  	      first_name,
 35  	      letter||'.',
 36  	      last_name,
 37  	      WORKER.get_formatted_name(
 38  		first_name, letter||'.', last_name),
 39  	      DATE_.random(
 40  		to_number(to_char(SYSDATE, 'YYYY')) - 65,
 41  		to_number(to_char(SYSDATE, 'YYYY')) - 18),
 42  	      decode(gender_code, 'F', n_G_FEMALE, n_G_MALE))
 43    from   RPS.TOP_100_LAST_NAMES,
 44  	      RPS.TOP_100_FIRST_NAMES,
 45  	      RPS.A_THRU_Z;
 46  
 47    n_inserted := n_inserted + sql%rowcount;
 48  
 49    commit;
 50  
 51    pl(to_char(n_inserted)||' rows inserted in '||
 52  	 (to_number(to_char(SYSDATE, 'SSSSS')) - n_start)||
 53  	 ' seconds.');
 54  end;
 55  /
260000 rows inserted in 130 seconds.

PL/SQL procedure successfully completed.

SQL> 
SQL> execute SYS.DBMS_STATS.gather_table_stats(USER, 'WORKERS');

PL/SQL procedure successfully completed.

SQL> 
SQL> @gender_typez.vw
SQL> rem gender_typez.vw
SQL> rem by Donald J. Bales on 2014-10-20
SQL> rem Create an object view for relational table GENDER_TYPES
SQL> 
SQL> create view GENDER_TYPEZ of GENDER_TYPE
  2  with object identifier (id) as
  3  select id,
  4  	    code,
  5  	    description,
  6  	    active_date,
  7  	    inactive_date
  8  from   RPS.GENDER_TYPES;

View created.

SQL> @worker_typez.vw
SQL> rem worker_typez.vw
SQL> rem by Donald J. Bales on 2014-10-20
SQL> rem Create an object view for table WORKER_TYPES
SQL> 
SQL> create view WORKER_TYPES of WORKER_TYPE
  2  with object identifier (id) as
  3  select id,
  4  	    code,
  5  	    description,
  6  	    active_date,
  7  	    inactive_date
  8  from   RPS.WORKER_TYPES;
from   RPS.WORKER_TYPES
           *
ERROR at line 8:
ORA-00955: name is already used by an existing object


SQL> 
SQL> spool off;
